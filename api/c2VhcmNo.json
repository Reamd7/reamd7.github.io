[{"title":"React笔记: 2.3 classComponent 生命周期——更新阶段","date":"2021-04-09T20:57:24.000Z","date_formatted":{"ll":"2021年4月9日","L":"2021/04/09","MM-DD":"04-09"},"updated":"2021-04-08T16:51:35.492Z","content":"\nreference: https://react.docschina.org/docs/react-component.html\n\n卸载阶段\ncomponentwillunmount\ncomponentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。\ncomponentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。\n","plink":"https://xn--vqq264efum.com/20210409/React笔记-2-3-classComponent-生命周期——更新阶段/"},{"title":"React笔记: 2.2 classComponent 生命周期——更新阶段","date":"2021-04-04T20:57:24.000Z","date_formatted":{"ll":"2021年4月4日","L":"2021/04/04","MM-DD":"04-04"},"updated":"2021-04-08T16:50:19.042Z","content":"\nreference: https://react.docschina.org/docs/react-component.html\n\n\n\nReact笔记: 2.1 classComponent 生命周期——挂载阶段\ngraph TD\n    GetDerivedStateFromProps[static getDerivedStateFromProps]\n    GetDerivedStateFromProps[static getDerivedStateFromProps] --> shouldComponentUpdate[shouldComponentUpdate]\n    shouldComponentUpdate[shouldComponentUpdate] --> render(render)\n    render[render] --> getSnapshotBeforeUpdate(getSnapshotBeforeUpdate)\n    getSnapshotBeforeUpdate[getSnapshotBeforeUpdate] --> componentDidUpdate(componentDidUpdate)\n更新阶段\nstatic getDerivedStateFromProps\ngetDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。\n\n并且，这个方法一定要和 componentDidUpdate 一起使用，否则控制台也会有警告。\n\nTODO getDerivedStateFromProps 的用例以及对比\nshouldComponentUpdate(nextProps, nextState)\n\nhttps://react.docschina.org/docs/react-component.html#shouldcomponentupdate\n根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。\n当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。\nPureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。\n\n如果能和 immutable 数据结构 一起用 + PureComponent 性能更好，\n当然你也可以在其中修改他默认的行为\n例如：\n\nprops.name &amp; props.pwd 同时修改时候，Component才进行更新，其中一个更新都不进行更新\nprops.SomePropsName 只有他更新的情况下，才进行更新。\n\n从减少更新从而进行性能优化\nrender ———— JSX\ngetSnapshotBeforeUpdate(prevProps, prevState)\n\nhttps://react.docschina.org/docs/react-component.html#getSnapshotBeforeUpdate\ngetSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。\n此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。\n应返回 snapshot 的值（或 null）。\n\n从官方的demo中，我们理解到有一个情况：\n\n因为用 fiber 策略的情况，有可能 component 不是实时更新的，可能延后，也可能合并更新，这里的延迟：\n所以，一些依赖于渲染平台的实时值的情况，可以在这里求值。\n\n\n\n在上述示例中，重点是从 getSnapshotBeforeUpdate 读取 scrollHeight 属性，因为 “render” 阶段生命周期（如 render）和 “commit” 阶段生命周期（如 getSnapshotBeforeUpdate 和 componentDidUpdate）之间可能存在延迟。\n\n如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 getSnapshotBeforeUpdate() 中。\ncomponentDidUpdate(prevProps, prevState, snapshot)\n如果你需要执行副作用（例如，数据提取或动画）以响应 props 中的更改，请改用 componentDidUpdate 生命周期。\n","plink":"https://xn--vqq264efum.com/20210404/React笔记-2-2-classComponent-生命周期——更新阶段/"},{"title":"React笔记: 2.1.1 classComponent 生命周期 defaultProps类型提示坑的写法","date":"2021-04-04T12:34:36.000Z","date_formatted":{"ll":"2021年4月4日","L":"2021/04/04","MM-DD":"04-04"},"updated":"2021-04-04T14:50:28.454Z","content":"defaultProps 下类型提示的写法：\n// 重要核心 ！！ReactElement.js 中\n// // Resolve default props\n// if (type &amp;&amp; type.defaultProps) &#123;\n//   const defaultProps = type.defaultProps;\n//   for (propName in defaultProps) &#123;\n//     if (props[propName] === undefined) &#123; // 排除了undefined\n//       props[propName] = defaultProps[propName];\n//     &#125;\n//   &#125;\n// &#125;\n\n\n原有的defaultProps的 typescript react 是边界情况有误的。\nReactElement.js 中对 defaultProps 的处理情况中，不会处理undefined的值\n所以在 typescript 中 如果在 defaultProps 中 有 undefined 的 值， 对应的字段名是不应该覆盖原有的Props 定义的。\n\n原有的Demo，也是错误的根源。\n12345678910111213141516171819202122232425262728293031import React from &quot;react&quot;;type ComponentTestProps = &#123;  test: boolean;  quiet?: boolean;  name: string;&#125;;type ComponentTestState = &#123;  updateString: string;&#125;;class ComponentTest extends React.Component&lt;  ComponentTestProps,  ComponentTestState&gt; &#123;  props: ComponentTestProps;  static defaultProps = &#123;    test: true,    quiet: false,    name: undefined, // 错误的根源  &#125;;  state = &#123;    updateString: &quot;hello world&quot;,  &#125;;  constructor(props: ComponentTestProps) &#123;    super(props);    this.props = props;  &#125;&#125;function Main() &#123;  return &lt;ComponentTest /&gt;; // 这里不会 ts Error, 但是运行时会有 error ，如果没有处理name的情况而完全相信ts的情况下。&#125;\n思路1：借用 utility-types 的 一系列工具类型，以排除 undefined 类型\n\n但是这个只是第一层的思路，（既没有检查defaultProps，又不能抽象出ActiveProps 的泛型）。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from &quot;react&quot;;import &#123; OmitByValueExact, Assign &#125; from &quot;utility-types&quot;;type ComponentTestProps = &#123;  test: boolean;  quiet?: boolean;  name: string;&#125;;type ComponentTestState = &#123;  updateString: string;&#125;;type ActiveProps = Assign&lt;  Partial&lt;    Pick&lt;      ComponentTestProps,      keyof OmitByValueExact&lt;typeof defaultProps, undefined&gt;    &gt;  &gt; &amp;    Omit&lt;      ComponentTestProps,      keyof OmitByValueExact&lt;typeof defaultProps, undefined&gt;    &gt;,  &#123;&#125;&gt;;const defaultProps = &#123;  test: true,  quiet: false,  name: undefined, // 这里有一个奇怪的ts问题，我并不知道ts做了什么进行对defaultProps的操作。但是显然与我ActiveProps的东西不一样的&#125;;const ComponentTest = (class extends React.Component&lt;  ComponentTestProps,  ComponentTestState&gt; &#123;  props: ComponentTestProps;  static defaultProps = defaultProps;  state = &#123;    updateString: &quot;hello world&quot;,  &#125;;  constructor(props: ComponentTestProps) &#123;    super(props);    this.props = props;  &#125;&#125; as unknown) as React.ComponentClass&lt;ActiveProps, ComponentTestState&gt;;function Main() &#123;  return &lt;ComponentTest /&gt;; // Error ! 类型 &quot;&#123;&#125;&quot; 中缺少属性 &quot;name&quot;，但类型 &quot;Readonly&lt;ActiveProps&gt;&quot; 中需要该属性。&#125;\n⭐改进思路2：检查defaultProps的类型，从而无所谓 undefined 类型了。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React from &quot;react&quot;;// 能够用泛型来构建出一个type ActiveProps&lt;T, K extends keyof T&gt; = Partial&lt;Pick&lt;T, K&gt;&gt; &amp; Omit&lt;T, K&gt;;/** * 这是 ComponentTest 实际的 Props */type ComponentTestProps = &#123;  test: boolean;  quiet?: boolean;  name: string;  children?: React.ReactNode;&#125;;type ComponentTestState = &#123;  updateString: string;&#125;;const defaultProps = &#123;  test: true,  quiet: undefined,  name: &quot;undefined&quot;,&#125;;const ComponentTest = class extends React.Component&lt;  ComponentTestProps,  ComponentTestState&gt; &#123;  props: ComponentTestProps;  static defaultProps: Pick&lt;    ComponentTestProps,    keyof typeof defaultProps  &gt; = defaultProps; // 这里是重要的以进行 defaultProps 的类型限制，用这个操作 可以不需要用到检查 undefined 思路——只要保证defaultProps一定是Props的子类型即可  state = &#123;    updateString: &quot;hello world&quot;,  &#125;;  constructor(props: ComponentTestProps) &#123;    super(props);    this.props = props;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;span&gt;&#123;this.props.name&#125;&lt;/span&gt;        &#123;this.props.children&#125;      &lt;/div&gt;    );  &#125;&#125; as React.ComponentClass&lt;  ActiveProps&lt;ComponentTestProps, keyof typeof defaultProps&gt;,  ComponentTestState&gt;;export default ComponentTest;","plink":"https://xn--vqq264efum.com/20210404/React笔记-2-1-1-classComponent-生命周期_defaultProps类型提示坑的写法/"},{"title":"React笔记: 2.1 classComponent 生命周期——挂载阶段","date":"2021-03-26T12:34:36.000Z","date_formatted":{"ll":"2021年3月26日","L":"2021/03/26","MM-DD":"03-26"},"updated":"2021-04-04T14:36:44.597Z","content":"\nreference: https://react.docschina.org/docs/react-component.html\n\n\n\n挂载阶段\nconstructor -&gt; static getDerivedStateFromProps -&gt; render -&gt; componentDidMount\ngraph TD\n    Constructor[constructor] --> GetDerivedStateFromProps[static getDerivedStateFromProps]\n    GetDerivedStateFromProps[static getDerivedStateFromProps] --> Render[render]\n    Render[render] --> componentDidMount(componentDidMount)\nconstructor\n\n处理 props 默认值（可以用defaultProps，还是推荐用defaultProps），但是有一些问题：\n⭐处理 state 默认值\n原来有人用bind(this) 处理事件，但是现在都用箭头函数了。\n\ntypescript 下，安全 defaultProps 类型提示的写法：\nrender —— return JSX\ncomponentDidMount\n进行 useEffect 的 一堆副作用操作，例如：\n\n依赖于 DOM 节点的初始化应该放在这里。\n定时器\n如需通过网络请求获取数据，此处是实例化请求的好地方。\n这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅\n\n但是如果在之前执行，则会阻碍组件的实例化，阻碍组件的渲染\n!! 你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理\n","plink":"https://xn--vqq264efum.com/20210326/React笔记-2-1-classComponent-生命周期——挂载阶段/"},{"title":"React笔记: 1.classComponent 与 FunctionComponent HelloWorld","date":"2021-03-26T11:10:00.000Z","date_formatted":{"ll":"2021年3月26日","L":"2021/03/26","MM-DD":"03-26"},"updated":"2021-03-26T04:13:43.792Z","content":"1.classComponent\n\n\n\n2.FunctionComponent\n\n\n","plink":"https://xn--vqq264efum.com/20210326/React笔记-1-classComponent-与-FunctionComponent-HelloWorld/"},{"title":"重学前端笔记","date":"2020-01-08T14:00:42.000Z","date_formatted":{"ll":"2020年1月8日","L":"2020/01/08","MM-DD":"01-08"},"updated":"2020-01-13T12:56:05.000Z","content":"明确路线\n总纲：将所有的文章根据原有的大纲排序\n\n关于前端工程师成长，我认为需要两个视角。\n一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；\n二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。\n只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。\n\n\n\n开篇词\n\n\n明确前端学习路线\n\n\n列一份前端知识架构图\n\n\nJavascript\n\n05-JavaScript类型：关于类型，有哪些你不知道的细节？_For_group_share\n06-JavaScript对象：面向对象还是基于对象？_For_group_share\n07-JavaScript对象：我们真的需要模拟类吗？_For_group_share\n08-JavaScript对象：你知道全部的对象分类吗？_For_group_share\n16-JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？_For_group_share\n17-JavaScript执行（二）：闭包和执行上下文到底是怎么回事？_For_group_share\n18-JavaScript执行（三）：你知道现在有多少种函数吗？_For_group_share\n19-JavaScript执行（四）：try里面放return，finally还会执行吗？_For_group_share\n26-JavaScript词法：为什么12.toString会报错？_For_group_share\n28-JavaScript语法（预备篇）：到底要不要写分号呢？_For_group_share\n29-JavaScript语法（一）：在script标签写export为什么会抛错？_For_group_share\n30-JavaScript语法（二）：你知道哪些JavaScript语句？_For_group_share\n31-JavaScript语法（三）：什么是表达式语句？_For_group_share\n32-JavaScript语法（四）：新加入的–运算符，哪里有些不一样呢？_For_group_share\n27-（小实验）理解编译原理：一个四则运算的解释器_For_group_share\n\n\n\nHTML\n\n03-HTML语义：div和span不是够用了吗？_For_group_share\n04-HTML语义：如何运用语义类标签来呈现Wiki网页？_For_group_share\n15-HTML元信息类标签：你知道head里一共能写哪几种标签吗？_For_group_share\n23-HTML链接：除了a标签，还有哪些标签叫链接？_For_group_share\n33-HTML替换型元素：为什么link一个CSS要用href，而引入js要用src呢？_For_group_share\n34-HTML小实验：用代码分析HTML标准_For_group_share\n39-HTML语言：DTD到底是什么？_For_group_share\n42-HTML·ARIA：可访问性是只给盲人用的特性么？_For_group_share\n\n\n\nCSS\n\n09-CSS语法：除了属性和选择器，你还需要知道这些带@的规则_For_group_share\n20-CSS选择器：如何选中svg里的a元素？_For_group_share\n21-CSS选择器：伪元素是怎么回事儿？_For_group_share\n24-CSS排版：从毕升开始，我们就开始用正常流了_For_group_share\n35-CSSFlex排版：为什么垂直居中这么难？_For_group_share\n38-CSS动画与交互：为什么动画要用贝塞尔曲线这么奇怪的东西？_For_group_share\n40-CSS渲染：CSS是如何绘制颜色的？_For_group_share\n41-CSS小实验：动手做，用代码挖掘CSS属性_For_group_share\n\n\n\nbroswer 浏览器实现原理与API\n\n10-14 浏览器：一个浏览器是如何工作的？_For_group_share\n22-浏览器DOM：你知道HTML的节点有哪几种吗？_For_group_share\n25-浏览器CSSOM：如何获取一个元素的准确位置_For_group_share\n36-浏览器事件：为什么会有捕获过程和冒泡过程？_For_group_share\n37-浏览器API（小实验）：动手整理全部API_For_group_share\n\n\n\n前端综合应用\n\n43-性能：前端的性能到底对业务数据有多大的影响？_For_group_share\n44-工具链：什么样的工具链才能提升团队效率？_For_group_share\n45-持续集成：几十个前端一起工作，如何保证工作质量？_For_group_share\n46-搭建系统：大量的低价值需求应该如何应对？_For_group_share\n47-前端架构：前端架构有哪些核心问题？_For_group_share\n加餐-前端与图形学_For_group_share\n加餐-前端交互基础设施的建设_For_group_share\n\n\n\nJavascript\n\n从运行时、文法和执行过程三个角度去剖析JS的知识体系\n\n笔记 05-JavaScript类型：关于类型，有哪些你不知道的细节？\n\n\n6 ES 数据类型和值\n\n\n7.1 类型转换\n\n\nES 语言类型\n\n\nES 语言类型包括 Undefined、Null、Boolean、String、Symbol、Number 和 Object。\n\nUndefined 类型：\n\nUndefined 类型有且只有一个值，称为 undefined 。任何没有被赋值的变量的值都是 undefined\n\n\nNull 类型：\n\nNull 类型有且只有一个值，称为 null\n\n\nBoolean 类型：\n\nBoolean 类型表示逻辑实体，有两个值，称为 true 和 false。\n\n\nString 类型：\n\n由零个或多个（最多有 253 - 1 个）16 位 Unicode 字符组成的字符序列。\nUTF-16 ( 具体在于这个Spec )\nUTF-16\nUnicode、\n\n\nNumber 类型：\n\n数值类型拥有 18437736874454810627（即，264-253+3）个值，表示为 IEEE-754-2008 格式 64 位双精度数值（IEEE 标准的二进制浮点数算术中描述了它）\\\n安全整数\n\n\n\n\n\n笔记 06-JavaScript对象：面向对象还是基于对象？\n\n什么是面向对象？\nJavascript 的 对象模型\n\nObject 类型\n\n\n\n\n参考资料：\n\nspec\n\nECMAScript® 2019 语言规范\nECMAScript® 2018 Language Specification 中文\nes7 中文\nes5 中文\n\n\nblog\n\n帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）\n\n\n\n","plink":"https://xn--vqq264efum.com/20200108/重学前端笔记/"},{"title":"重学前端_1_明确路线","date":"2020-01-07T15:43:15.000Z","date_formatted":{"ll":"2020年1月7日","L":"2020/01/07","MM-DD":"01-07"},"updated":"2020-01-08T13:14:56.000Z","content":"重学前端: 1. 明确路线\n参考书籍：\n\n《JavaScript高级程序设计》\n《精通CSS》\nMDN\n\n建立知识架构\n\n最重要的就是逻辑性和完备性。\n\nJavascript:\n\n对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程。\n\n\n文法 ( 来自编译原理的划分 )\n\n词法\n语法\n\n\n语义 ( 语义则跟语法具有一一对应关系 )\n运行时\n\n对运行时来说，类型就是数据结构，执行过程就是算法。\n程序 = 算法 + 数据结构\n\n\n类型\n执行过程\n\n\n\n","plink":"https://xn--vqq264efum.com/20200107/重学前端-1-明确路线/"},{"title":"前端随笔","date":"2020-01-07T13:42:20.000Z","date_formatted":{"ll":"2020年1月7日","L":"2020/01/07","MM-DD":"01-07"},"updated":"2020-01-08T13:14:56.000Z","content":"\n\ntypescript mix swaggerapi\nhttps://github.com/differui/oas-typegen\n\n\nReact Native 研究与实践\nhttps://github.com/crazycodeboy/RNStudyNotes\n\n\njsproxy：\nhttps://github.com/EtherDream/jsproxy-browser\n\n\n前端录屏：rrweb\n\n\npolyfill 方案：\n\n\n预先缓存polyfill\tcached per-useragent polyfills from polyfills.io\nhttps://github.com/datawrapper/polyfills\n\n\n支持IE6+的fetch 方案：\nhttps://github.com/RubyLouvre/fetch-polyfill\n\n\nproxy-polyfill（意义不大的方案）\nhttps://github.com/GoogleChrome/proxy-polyfill\n\n\n\n\n一个我觉得挺好能够支持SPA和SSR方案的React 状态和数据管理形式\n\n\nhttps://github.com/wooline/react-coat\n\n\n低代码方案：\n\n\nant-design 组件库实时可视化编辑器，实时生成 react 代码\nhttps://github.com/xinyu198736/antd-visual-editor\n\n\n\n\nCS （computer science）\n\nhttps://github.com/Reamd7/USTC-CS-Courses-Resource\nhttps://github.com/GreatWallFire/USTC-CS-Courses-Resource\nhttps://github.com/ustcwpz/USTC-CS-Courses-Resource\nhttps://github.com/Reamd7/CS\nhttps://github.com/Salensoft/thu-cst-cracker\nhttps://github.com/Reamd7/THU-CST-Cracker\n\n\n\n自己学习的项目：\n\nedu\nmanagerApp\n⭐前端监控（客户端的埋点做好了，后台功能没完成）\n\n\n\njs_score 性能\n\n不同的情况下js的性能对比\n\n\n\n","plink":"https://xn--vqq264efum.com/20200107/前端随笔/"},{"title":"使用husky和lint-staged来构建你的前端工作流","date":"2020-01-07T13:37:04.000Z","date_formatted":{"ll":"2020年1月7日","L":"2020/01/07","MM-DD":"01-07"},"updated":"2020-01-08T13:14:56.000Z","content":"使用 husky 和 lint-staged 来构建你的前端工作流\ngit commit 是最常用的命令之一，它可以触发四个 hook ，分别是 pre-commit, prepare-commit-msg, commit-msg 和 post-commit。 从字面上猜测着四个 hook 分别对应了 “commit 之前”，“准备 commit log message 的时候”，“生成 commit log message 的时候”，“commit 之后”四个阶段。\nhusky\ngit hook 中执行 node script\nprettier\n格式化代码\nhttps://prettier.io/\neslint\nes / ts 静态检验\nhttps://eslint.org/\nStylelint\ncss scss less 静态检验\nhttps://stylelint.io/user-guide/rules/function-calc-no-invalid\nlint-staged\n文件过滤：一个仅仅过滤出Git代码暂存区文件(被committed的文件)的工具。\n1yarn add --dev husky prettier eslint stylelint lint-staged\nCRA rewrite\ncustomize-cra / react-app-rewired\n1yarn add --dev customize-cra react-app-rewired\n\nbabel-plugin-import\nless less-loader\n\n1yarn add less less-loader babel-plugin-import --dev\noas-typegen API 生成器\n开发使用到的另外的库\nbig.js (数字精度计算)\nqr.js (生成二维码)\n","plink":"https://xn--vqq264efum.com/20200107/使用husky和lint-staged来构建你的前端工作流/"},{"title":"前端架构思考随笔","date":"2020-01-07T13:35:13.000Z","date_formatted":{"ll":"2020年1月7日","L":"2020/01/07","MM-DD":"01-07"},"updated":"2020-01-13T12:56:05.000Z","content":"前端架构\n强业务相关，视图业务尽量解耦（可以实现跨端）\n- Common 公共\n\nutils 工具函数\nconstans 变量\ntypes 类型\n\n- infrastructure 层 对底层技术进行封装操作（AOP）\n\n如果有跨平台要求，最好是在这一层抹平平台之间的差异（平台相关的），基础设施层级\n\n\n以前写thinkphp，对不同平台代码进行适配的情况会有一个driver的想法，\n\n\nethers.js 中 对 Provider 的封装就是也是这个思路\n\n\n\n\n封装 AJAX 请求\n\nAJAX中有 translator 转换器层，主要是对后端提供的接口进行数据的转换修正，\n\n\n操作浏览器 cookie、locaStorage、indexDB，\n操作 native 提供的能力（如调用摄像头等），\n建立 Websocket 与后端进行交互等。\n\n- 领域 Domain 层\n\n实体由数据表达，实体中的函数都是由数据中加逻辑而成的，不依赖外部，形成单独的领域概念\n\n实体 Entity\n- Service 服务层\n\n依赖 infrastructure 和 Domain 层，可使用不同的领域，用 infrastructure  的功能实现不同的 Service\n面向数据（Entity），不是面向业务\n\n数据访问层 DAO Service（这是最主要的）\n\n依赖于 Entity 和  Infrastructure （平台无关）\n\n\n后端：sql-&gt;param-&gt;getResult\n前端：url-&gt;param-&gt;getResult\n所谓事务，是指\n后端实现，按不同的需求调用不同的数据访问层方法，这里有事务的概念。\n前端实现，按不同的需求调用不同的数据访问层方法，这里不需要事务的概念，一定要有的话，一个是后端可以帮你变没有，一个是用 Promise.all 吧。事务这个概念在前端基本不存在，或者这种情况不多，但总有变通的办法嘛~\n\nOther Service 其他 Service\n\n本地储存 / 文件持久化\nwebsocket 连接\n图像处理…\n\n- application 用户逻辑层 ，\n\n依赖 Service 层，可使用不同的 Service\n面向业务，以业务为中心进行Service的调度。\n\nState Bridge 状态桥\n\nViewModel 中的 M，\n\ninput Interface 用户输入层\n\n\n后端实现， 拿到前端传回的参数，格式化数据，调用业务逻辑层的方法。格式化结果，返回数据。\n\n\n前端实现，拿到用户数据，格式化数据，调用业务逻辑层的方法，格式化结果，渲染页面。（基本都是View层）\n\n\n分层介绍\ndomain层\n在这一层中，我们可以定义充当实体和业务规则的角色并与我们的域有直接关系的单元。例如，在用户和团队的应用程序中，我们可能会有一个User实体，一个Team实体和一个JoinTeamPolicy来回答用户是否能够加入给定的团队。\n这是我们软件中最隔离，最重要的层，应用程序层可以使用它来定义用例。\napplication层\n应用程序层定义了我们应用程序的实际行为，因此负责执行域层各单元之间的交互。例如，我们可以有一个JoinTeam 用例，用于接收User和的实例Team并将其传递给JoinTeamPolicy;。如果用户可以加入，它将持久性责任委托给基础结构层。\n应用程序层也可以用作基础结构层的适配器。假设我们的应用程序可以发送电子邮件；负责直接与电子邮件服务器交谈的类（我们称之为MailChimpService）属于基础结构层，但实际发送电子邮件的类（EmailService）属于应用程序层并在MailChimpService内部使用。因此，我们的应用程序的其余部分不知道有关特定实现的详细信息-它仅知道EmailService能够发送电子邮件。\ninfrastructure 层\n这是所有层中的最低层，它是应用程序外部的边界：数据库，电子邮件服务，队列引擎等。\n多层应用程序的一个共同特征是使用存储库模式与数据库或其他一些外部持久性服务（例如API）进行通信。存储库对象本质上被视为集合，使用它们的层（域和应用程序）不需要知道底层的持久性技术（类似于我们的电子邮件服务示例）。\n这里的想法是存储库接口属于 domain 层，而实现又属于 infrastructure  层，\n即域仅知道存储库接受的方法和参数。即使在测试方面，这也使两层都更加灵活！由于JavaScript并未实现接口的概念，因此我们可以想象自己的接口，并以此为基础在基础结构层上创建具体的实现。\ninput interface 层\n该层包含应用程序的所有入口点，例如控制器，CLI，websocket，图形用户界面（如果是桌面应用程序）等等。\n它应该不具有有关业务规则，用例，持久性技术的知识，甚至不具备其他逻辑的知识！它应该只接收用户输入（如URL参数），将其传递给用例，最后将响应返回给用户。\n前后端对比\n其中 domain 层和 application 层在前端和后端之间是没有什么不同的，因为它们是与技术无关的，但是对于 input 层和 infrastructure 层我们不能这么说。\n在 Web 浏览器中 input 层通常只有一个角色–view。\n所以我们甚至可以称之为 view 层。\n同样在前端是无法操作数据库或队列引擎的，所以我们无法在前端的 infrastructure 层中找到它们。\n相反我们能够找的是封装 AJAX 请求、浏览器 cookie、LocalStorage，甚至是与 WebSocket 服务器交互的模块的抽象。\n所以对应来说\ndomain 领域层 ，application 应用层 前后端应可以完全复用模块\ninput层，对于后端来说主要是Controller 接受 url 参数，对于前端来说就是View层。\ninfrastructure ，就是不同平台上对底层技术进行封装操作的一层，尽量抹平平台之间的差异。\n主要的区别是被抽象的内容，所以前端和后端的 Repository 甚至可以有完全一致的接口而底层是不同的技术。你能看到一个好的抽象有多棒了吗？\n\n\n关于基于前端分层的架构，还有另一个重要规则：使 view 层始终与本地状态保持同步，你应该遵循单向数据流原则。我们可以通过添加第五个层来达到这个目的：state ，或者称为 store。\n","plink":"https://xn--vqq264efum.com/20200107/前端架构思考随笔/"},{"title":"feflow WeFlow 工程化实践","date":"2020-01-06T21:55:41.000Z","date_formatted":{"ll":"2020年1月6日","L":"2020/01/06","MM-DD":"01-06"},"updated":"2020-01-06T15:43:53.000Z","content":"topic: workflow\nhttps://github.com/topics/workflow?l=javascript\ngithub/feflow\n\nfellow-cli 项目正好可以学习 nodejs 中 cli 开发的 library\n\n\n参考资料:\n\n\n腾讯IVWEB前端工程化工具feflow思考与实践\n\n\nhttps://github.com/Tencent/feflow\n\n\nfeflow 插件实现原理\n\n\n利用yeoman构建项目generator\n\n\nnormal\n\n如何写一个通用的README规范\ngit commit 代码提交规范\n\n\n\nTencent/WeFlow\n\n参考资料:\n\nhttps://weflow.io/\nhttps://github.com/Tencent/WeFlow\n\n","plink":"https://xn--vqq264efum.com/20200106/feflow工程化实践/"},{"title":"react 源码阅读计划","date":"2020-01-02T13:45:00.000Z","date_formatted":{"ll":"2020年1月2日","L":"2020/01/02","MM-DD":"01-02"},"updated":"2020-01-06T15:57:44.000Z","content":"目标课程：React 源码深度解析 高级前端工程师必备技能\n\n参考资料 https://react.jokcy.me\n\n第 1 章 课程导学\n对课程整体进行讲解。\n第 2 章 基础知识 React API 一览（完成）\nReact 主要 API 介绍，在这里你能了解它的用法，为下一章源码分析打基础。\n第 3 章 React 中的更新\n主要讲解 React 创建更新中的主要两种方式 ReactDOM.render 和 setState，他们具体做了什么。\n\n3-1 react-dom-render\n3-2 react-fiber-root\n3-3 react-fiber\n3-4 react-update-and-updateQueue\n3-5 react-expiration-time\n3-6 different-expirtation-time\n3-7 react-setState-forceUpdate\n\n第 4 章 Fiber Scheduler\n创建更新之后，找到 Root 然后进入调度，同步和异步操作完全不同，实现更新分片的性能优化。\n\n4-1 总结流程概览\n4-2 scheduleWork\n4-3 requestWork\n4-4 batchedUpdates\n4-5 reactScheduler（1）\n4-6 reactScheduler（2）\n4-7 reactScheduler（3）\n4-8 reactScheduler（4）\n4-9 performWork\n4-10 renderRoot\n4-11 最后补充\n\n第 5 章 各类组件的 Update\n讲解 10 多种不同类型的组件的更新过程，以及如何遍历节点形成新的 Fiber 树\n\n5-1 入口和优化\n5-2 FunctionalComponent 的更新\n5-3 reconcilerChildren\n5-4 reconcilerChildren-array\n5-5 updateClassComponent\n5-6 ClassComponent 的更新\n5-7 IndeterminateComponent 组件类型和其更新过程\n5-8 HostRoot 的更新\n5-9 HostComponent 和 HostText 的更新\n5-10 Poratl 组件的更新\n5-11 ForwardRef 的更新\n5-12 Mode 组件的更新\n5-13 Memo 组件的更新\n\n第 6 章 完成节点任务\n完成节点更新之后完成节点的创建，并提供优化到最小幅度的 DOM 更新列表\n\n6-1 completeUnitOfWork 的整体流程和意义\n6-2 重设 childExpirationTime\n6-3 completWork 具体做了什么\n6-4 初次渲染中 completeWork 对于 DOM 节点的创建和 appendAllChild 算法\n6-5 初次渲染中如何进行 DOM 节点属性初始化操作\n6-6 更新 DOM 时进行的 diff 判断\n6-7 completeWork 阶段对于 HostText 的更新\n6-8 renderRoot 中对于错误的处理\n6-9 unwindWork 以及 React 中的错误处理\n\n第 7 章 commitRoot\n根据更新列表最小幅度的改变 DOM，实现 UI 的更新。\n\n7-1 commitRoot 的总体工作内容\n7-2 invokeGuardedCallback 开发时的帮助方法\n7-3 commitRoot 第一个操作-获取快照\n7-4 commitAllHostEffects 总体做了哪些事情\n7-5 commitPlacement 插入新的子节点的操作\n7-6 commitWork 更新节点属性的过程\n7-7 commitWork 删除节点的操作过程\n7-8 commitLifecycles 调用生命周期方法\n\n第 8 章 功能详解：基础\n各种贯穿于更新和提交阶段的功能，他们在哪里发挥作用，又是如何实现功能的\n\n8-1 context-stack\n8-2 遗留 context-api 的实现过程（1）\n8-3 遗留 context-api 的实现过程（2）\n8-4 新 context 的实现\n8-5 ref 的实现过程\n8-6 hydrate-是否需要 hydrate 的判断\n8-7 hydrate-更新开始判断节点是否可以 hydrate\n8-8 hydrate-再 completeWork 中复用可 hydrate 的节点\n8-9 event 事件系统初始化-注入平台事件插件\n8-10 event 事件监听的过程\n8-11 event-事件触发的过程\n8-12 event-事件对象的生产过程\n8-13 event 查漏补缺\n\n第 9 章 suspense and priority\nSuspense 作为下一个 React 的杀手功能，他又是如何实现异步渲染的呢？\n\n9-1 优先级和任务挂起的含义（1）\n9-2 优先级和任务挂起的含义（2）\n9-3 两个 expirationTime 的不同作用\n9-4 Suspense 组件同步模式下的更新\n9-5 Suspense 组件同步渲染模式补充\n9-6 Suspense 组件异步模式下的更新\n9-7 retrySuspendedWork 所做的事情\n\n第 10 章 功能详解：Hooks\nHooks 颠覆原先的 React 组件开发模式，提供更小粒度的更新以及更加适合解耦的 API。\n\n10-1 什么是 Hooks 以及他的用法\n10-2 Hooks 的定义以及执行前后的准备和重置\n10-3 useState 的实现原理和注意事项（1）\n10-4 useState 的实现原理和注意事项（2）\n10-5 useEffect 和 useLayoutEffect 的实现原理和区别\n10-6 其他 Hooks 的实现\n\n第 11 章 课程总结\n对课程整体进行回顾，以及总结。\n\n11-1 课程总结\n\n","plink":"https://xn--vqq264efum.com/20200102/react-源码阅读计划/"},{"title":"taro 1、环境搭建","date":"2020-01-01T14:11:27.000Z","date_formatted":{"ll":"2020年1月1日","L":"2020/01/01","MM-DD":"01-01"},"updated":"2020-01-01T06:15:39.000Z","content":"","plink":"https://xn--vqq264efum.com/20200101/taro-1-环境搭建/"},{"title":"2020计划","date":"2020-01-01T11:55:36.000Z","date_formatted":{"ll":"2020年1月1日","L":"2020/01/01","MM-DD":"01-01"},"updated":"2020-01-06T15:57:44.000Z","content":"2020年的计划，技术投资\nwasm\n\n2020 年，我看好的是 wasm：\n优势：\n\n\n性能，相对与JS来说，更为底层WebAssembly，相对于JS有更多的性能提升。\n\n性能的提升可以让开发者增强在浏览器端的交互体验的能力，现在在做的前端音视频处理，还有Qrcode二维码扫描识别，这些cpu密集的使用场景，性能很重要。国内外webassembly的主要应用领域有Google Earth，Figma设计工具，大型游戏引擎，图像处理等。\n\n\n跨平台的可移植性\n\n\n平台无关、语言无关的底层指令集，有助于将很多高性能的C++的库迁移到wasm平台中，使得开发者能够直接使用高性能的库提升应用的性能\n\n\n\n\n愿景：我希望能够将Wasm带到跨端开发的维度上，wasm 不仅是局限于浏览器端，类似 wasmerio/wasmer 的库能够提供在非浏览器端平台支持的 wasm\n入门：离不开的一定是 Rust 语言，\n路线图：\n\n\nRust语言入门⭐(困难的，也是有益的)\n\n\n练手：基于Rust 语言的 yewstack/yew 框架开发 webapp\n\n\n进阶：基于Rust + React 底层原理，写一个React-like的框架出来\n\n\n装黑苹果，搭建 Android 开发环境 + IOS 开发环境\n\n\n\n在 Android 中，会使用 Rust 写扩展嵌入到 Android 中，将 wasm 的 vm 内嵌到安卓中\n在 IOS 中，会使用 Rust 写扩展嵌入到 IOS 中，将 wasm 的 vm 内嵌到IOS中\n如同 RN 的技术一样实现嵌入JS 引擎，实现 JSBridge\nhttps://www.jianshu.com/p/eff176e220e0 JavaScriptCore\nhttps://www.cnblogs.com/fengmin/p/5605913.html\n\n\n\n实现 JSBridge 的时候，就需要制定相关的JSI ( Javascript Interface ) 的规范，以符合wasm，和 Native 的无缝调用（降低性能损耗）\n\n\n… 目的，将 Native Code 的任何API都进行封装，允许 Rust 扩展层接入，然后提供到 wasm 层，\nJS 可以通过 特定的JSI，与wasm层进行扩展操作，如果遇见需高性能的地方，就直接使用asmscript 写 wasm，调用原生的api。最后，wasm 层面能够直接编写高性能的Native code 。\n应该可以理解为使用wasm 作为传统JSBridge的实现。\n基础能力\n打好 HTML CSS JS 的基础\n\n\n建立前端的技术框架，重学前端的课程\n\n\n填充，丰满框架的内容\n\n红宝书——《高程》\n《you dont know javascript 上中下》\n刷面经\n\n\n\n前端工程化：webpack的学习\n\n\nreact 源码阅读计划\n\n\n计算机基础\n\n算法与数据结构\n\n\n以 Leetcode 的刷题为核心，基础知识依赖《算法导论》来看\n\n\n参考资料：\n\nhttps://www.zhihu.com/question/280279208/answer/510354868\nhttps://leetcode-cn.com/\n⭐ https://leetcode-cn.com/explore/\n\n\n\n以leetcode 中的探索为开始，将卡片中的题目刷一下\n\n\n计算机网络知识\n\n\n《HTTP权威指南》\n《计算机网络——自顶向下方法》\n\n业务\n跨端实践\n\n基于React 技术栈，跨Web/小程序/RN App 开发的应用\n\nNode 层开发实践，\n\n给 App 提供简单的数据支持\n进阶：基于docker 的 本地service 搭建\n\n进阶 : Dapp\n\nethers.js\n模仿现有的交易所 App 进行开发，但不依赖于 Server 进行合约交易，直接使用客户端进行交易，Server层仅仅只是记录数据\n\n大型PC端，\n\n参考JEECG，技术栈不过是使用 Node + React （MERN）\n\n有东西的：\n\n解密国内BAT等大厂前端技术体系-完结篇\n\n","plink":"https://xn--vqq264efum.com/20200101/2020计划/"},{"title":"ethersjs源码阅读","date":"2019-12-15T11:45:59.000Z","date_formatted":{"ll":"2019年12月15日","L":"2019/12/15","MM-DD":"12-15"},"updated":"2020-01-08T13:14:56.000Z","content":"在ethersjs节点浏览器中获取启动节点\na.data.filter(val=&gt;val.client === “parity-ethereum”).map(val=&gt;enode://$&#123;val.id&#125;@$&#123;val.host&#125;:$&#123;val.port&#125;)\n","plink":"https://xn--vqq264efum.com/20191215/ethersjs源码阅读/"},{"title":"以太坊开发计划","date":"2019-12-15T10:15:01.000Z","date_formatted":{"ll":"2019年12月15日","L":"2019/12/15","MM-DD":"12-15"},"updated":"2019-12-15T02:37:36.000Z","content":"\n1、搭建本地测试网络\n\n官方网站：https://www.trufflesuite.com/ganache\nhttps://www.marser.cn/article/138.html\n\n\n2、基于parity 搭建以太坊的轻节点\n\n官方网站：https://www.parity.io/\nhttps://www.parity.io/ethereum/\n配置文件：https://paritytech.github.io/parity-config-generator/#config=eyJwYXJpdHkiOnsiYmFzZV9wYXRoIjoiQzpcXHBhcml0eVxcZm91bmRhdGlvbiIsImRiX3BhdGgiOiJDOlxccGFyaXR5XFxmb3VuZGF0aW9uXFxQYXJpdHlcXEV0aGVyZXVtXFxjaGFpbnMiLCJsaWdodCI6dHJ1ZX0sImFjY291bnQiOnsicmVmcmVzaF90aW1lIjowfSwicnBjIjp7ImFwaXMiOlsid2ViMyIsImV0aCIsIm5ldCIsInByaXZhdGUiLCJ0cmFjZXMiLCJycGMiLCJzaGgiLCJwYXJpdHkiLCJwYXJpdHlfYWNjb3VudHMiLCJwdWJzdWIiLCJwYXJpdHlfcHVic3ViIiwic2hoX3B1YnN1YiJdLCJjb3JzIjpbIiIsIiJdfSwiX19pbnRlcm5hbCI6eyJjb25maWdNb2RlIjoiYWR2YW5jZWQifX0=\n\n\n\n","plink":"https://xn--vqq264efum.com/20191215/以太坊开发计划/"},{"title":"进步计划","date":"2019-11-27T23:24:19.000Z","date_formatted":{"ll":"2019年11月27日","L":"2019/11/27","MM-DD":"11-27"},"updated":"2019-12-15T06:33:43.000Z","content":"\n\n逐步整理前端的积累代码\n\n\n性能提升想法：\n\n基于 script type=“module” 和 nomodule，对不直接转es6代码转es5\n单独使用 customElements 能力，隔离 react dom 树，增强性能\n遇见使用 immer.js 是有用的，因为能够渐进支持 Proxy ，defineProperty 的 immutable 的能力，Proxy 有效能够增强 defineProperty 的性能\n\n\n\n","plink":"https://xn--vqq264efum.com/20191127/进步计划/"},{"title":"Html Book","date":"2020-01-07T13:42:20.000Z","date_formatted":{"ll":"2020年1月7日","L":"2020/01/07","MM-DD":"01-07"},"updated":"2021-03-26T04:31:01.590Z","content":"Html Book\n\nEcma262\n\n","plink":"https://xn--vqq264efum.com/lang/"}]