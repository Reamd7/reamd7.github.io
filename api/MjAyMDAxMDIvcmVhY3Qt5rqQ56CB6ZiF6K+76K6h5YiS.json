{"title":"react 源码阅读计划","date":"2020-01-02T13:45:00.000Z","date_formatted":{"ll":"2020年1月2日","L":"2020/01/02","MM-DD":"01-02"},"link":"20200102/react-源码阅读计划","tags":["计划"],"updated":"2020-01-06T15:57:44.000Z","content":"<p>目标课程：<a href=\"https://coding.imooc.com/class/chapter/309.html\" target=\"_blank\">React 源码深度解析 高级前端工程师必备技能</a></p>\n<blockquote>\n<p>参考资料 <a href=\"https://react.jokcy.me\">https://react.jokcy.me</a></p>\n</blockquote>\n<h2 id=\"第-1-章-课程导学\">第 1 章 课程导学<a title=\"#第-1-章-课程导学\" href=\"#第-1-章-课程导学\"></a></h2>\n<p>对课程整体进行讲解。</p>\n<h2 id=\"第-2-章-基础知识-react-api-一览（完成）\">第 2 章 基础知识 React API 一览（完成）<a title=\"#第-2-章-基础知识-react-api-一览（完成）\" href=\"#第-2-章-基础知识-react-api-一览（完成）\"></a></h2>\n<p>React 主要 API 介绍，在这里你能了解它的用法，为下一章源码分析打基础。</p>\n<h2 id=\"第-3-章-react-中的更新\">第 3 章 React 中的更新<a title=\"#第-3-章-react-中的更新\" href=\"#第-3-章-react-中的更新\"></a></h2>\n<p>主要讲解 React 创建更新中的主要两种方式 ReactDOM.render 和 setState，他们具体做了什么。</p>\n<ul>\n<li>3-1 react-dom-render</li>\n<li>3-2 react-fiber-root</li>\n<li>3-3 react-fiber</li>\n<li>3-4 react-update-and-updateQueue</li>\n<li>3-5 react-expiration-time</li>\n<li>3-6 different-expirtation-time</li>\n<li>3-7 react-setState-forceUpdate</li>\n</ul>\n<h2 id=\"第-4-章-fiber-scheduler\">第 4 章 Fiber Scheduler<a title=\"#第-4-章-fiber-scheduler\" href=\"#第-4-章-fiber-scheduler\"></a></h2>\n<p>创建更新之后，找到 Root 然后进入调度，同步和异步操作完全不同，实现更新分片的性能优化。</p>\n<ul>\n<li>4-1 总结流程概览</li>\n<li>4-2 scheduleWork</li>\n<li>4-3 requestWork</li>\n<li>4-4 batchedUpdates</li>\n<li>4-5 reactScheduler（1）</li>\n<li>4-6 reactScheduler（2）</li>\n<li>4-7 reactScheduler（3）</li>\n<li>4-8 reactScheduler（4）</li>\n<li>4-9 performWork</li>\n<li>4-10 renderRoot</li>\n<li>4-11 最后补充</li>\n</ul>\n<h2 id=\"第-5-章-各类组件的-update\">第 5 章 各类组件的 Update<a title=\"#第-5-章-各类组件的-update\" href=\"#第-5-章-各类组件的-update\"></a></h2>\n<p>讲解 10 多种不同类型的组件的更新过程，以及如何遍历节点形成新的 Fiber 树</p>\n<ul>\n<li>5-1 入口和优化</li>\n<li>5-2 FunctionalComponent 的更新</li>\n<li>5-3 reconcilerChildren</li>\n<li>5-4 reconcilerChildren-array</li>\n<li>5-5 updateClassComponent</li>\n<li>5-6 ClassComponent 的更新</li>\n<li>5-7 IndeterminateComponent 组件类型和其更新过程</li>\n<li>5-8 HostRoot 的更新</li>\n<li>5-9 HostComponent 和 HostText 的更新</li>\n<li>5-10 Poratl 组件的更新</li>\n<li>5-11 ForwardRef 的更新</li>\n<li>5-12 Mode 组件的更新</li>\n<li>5-13 Memo 组件的更新</li>\n</ul>\n<h2 id=\"第-6-章-完成节点任务\">第 6 章 完成节点任务<a title=\"#第-6-章-完成节点任务\" href=\"#第-6-章-完成节点任务\"></a></h2>\n<p>完成节点更新之后完成节点的创建，并提供优化到最小幅度的 DOM 更新列表</p>\n<ul>\n<li>6-1 completeUnitOfWork 的整体流程和意义</li>\n<li>6-2 重设 childExpirationTime</li>\n<li>6-3 completWork 具体做了什么</li>\n<li>6-4 初次渲染中 completeWork 对于 DOM 节点的创建和 appendAllChild 算法</li>\n<li>6-5 初次渲染中如何进行 DOM 节点属性初始化操作</li>\n<li>6-6 更新 DOM 时进行的 diff 判断</li>\n<li>6-7 completeWork 阶段对于 HostText 的更新</li>\n<li>6-8 renderRoot 中对于错误的处理</li>\n<li>6-9 unwindWork 以及 React 中的错误处理</li>\n</ul>\n<h2 id=\"第-7-章-commitroot\">第 7 章 commitRoot<a title=\"#第-7-章-commitroot\" href=\"#第-7-章-commitroot\"></a></h2>\n<p>根据更新列表最小幅度的改变 DOM，实现 UI 的更新。</p>\n<ul>\n<li>7-1 commitRoot 的总体工作内容</li>\n<li>7-2 invokeGuardedCallback 开发时的帮助方法</li>\n<li>7-3 commitRoot 第一个操作-获取快照</li>\n<li>7-4 commitAllHostEffects 总体做了哪些事情</li>\n<li>7-5 commitPlacement 插入新的子节点的操作</li>\n<li>7-6 commitWork 更新节点属性的过程</li>\n<li>7-7 commitWork 删除节点的操作过程</li>\n<li>7-8 commitLifecycles 调用生命周期方法</li>\n</ul>\n<h2 id=\"第-8-章-功能详解：基础\">第 8 章 功能详解：基础<a title=\"#第-8-章-功能详解：基础\" href=\"#第-8-章-功能详解：基础\"></a></h2>\n<p>各种贯穿于更新和提交阶段的功能，他们在哪里发挥作用，又是如何实现功能的</p>\n<ul>\n<li>8-1 context-stack</li>\n<li>8-2 遗留 context-api 的实现过程（1）</li>\n<li>8-3 遗留 context-api 的实现过程（2）</li>\n<li>8-4 新 context 的实现</li>\n<li>8-5 ref 的实现过程</li>\n<li>8-6 hydrate-是否需要 hydrate 的判断</li>\n<li>8-7 hydrate-更新开始判断节点是否可以 hydrate</li>\n<li>8-8 hydrate-再 completeWork 中复用可 hydrate 的节点</li>\n<li>8-9 event 事件系统初始化-注入平台事件插件</li>\n<li>8-10 event 事件监听的过程</li>\n<li>8-11 event-事件触发的过程</li>\n<li>8-12 event-事件对象的生产过程</li>\n<li>8-13 event 查漏补缺</li>\n</ul>\n<h2 id=\"第-9-章-suspense-and-priority\">第 9 章 suspense and priority<a title=\"#第-9-章-suspense-and-priority\" href=\"#第-9-章-suspense-and-priority\"></a></h2>\n<p>Suspense 作为下一个 React 的杀手功能，他又是如何实现异步渲染的呢？</p>\n<ul>\n<li>9-1 优先级和任务挂起的含义（1）</li>\n<li>9-2 优先级和任务挂起的含义（2）</li>\n<li>9-3 两个 expirationTime 的不同作用</li>\n<li>9-4 Suspense 组件同步模式下的更新</li>\n<li>9-5 Suspense 组件同步渲染模式补充</li>\n<li>9-6 Suspense 组件异步模式下的更新</li>\n<li>9-7 retrySuspendedWork 所做的事情</li>\n</ul>\n<h2 id=\"第-10-章-功能详解：hooks\">第 10 章 功能详解：Hooks<a title=\"#第-10-章-功能详解：hooks\" href=\"#第-10-章-功能详解：hooks\"></a></h2>\n<p>Hooks 颠覆原先的 React 组件开发模式，提供更小粒度的更新以及更加适合解耦的 API。</p>\n<ul>\n<li>10-1 什么是 Hooks 以及他的用法</li>\n<li>10-2 Hooks 的定义以及执行前后的准备和重置</li>\n<li>10-3 useState 的实现原理和注意事项（1）</li>\n<li>10-4 useState 的实现原理和注意事项（2）</li>\n<li>10-5 useEffect 和 useLayoutEffect 的实现原理和区别</li>\n<li>10-6 其他 Hooks 的实现</li>\n</ul>\n<h2 id=\"第-11-章-课程总结\">第 11 章 课程总结<a title=\"#第-11-章-课程总结\" href=\"#第-11-章-课程总结\"></a></h2>\n<p>对课程整体进行回顾，以及总结。</p>\n<ul>\n<li>11-1 课程总结</li>\n</ul>\n","prev":{"title":"feflow WeFlow 工程化实践","link":"20200106/feflow工程化实践"},"next":{"title":"taro 1、环境搭建","link":"20200101/taro-1-环境搭建"},"plink":"https://xn--vqq264efum.com/20200102/react-源码阅读计划/","toc":[{"id":"第-1-章-课程导学","title":"第 1 章 课程导学","index":"1"},{"id":"第-2-章-基础知识-react-api-一览（完成）","title":"第 2 章 基础知识 React API 一览（完成）","index":"2"},{"id":"第-3-章-react-中的更新","title":"第 3 章 React 中的更新","index":"3"},{"id":"第-4-章-fiber-scheduler","title":"第 4 章 Fiber Scheduler","index":"4"},{"id":"第-5-章-各类组件的-update","title":"第 5 章 各类组件的 Update","index":"5"},{"id":"第-6-章-完成节点任务","title":"第 6 章 完成节点任务","index":"6"},{"id":"第-7-章-commitroot","title":"第 7 章 commitRoot","index":"7"},{"id":"第-8-章-功能详解：基础","title":"第 8 章 功能详解：基础","index":"8"},{"id":"第-9-章-suspense-and-priority","title":"第 9 章 suspense and priority","index":"9"},{"id":"第-10-章-功能详解：hooks","title":"第 10 章 功能详解：Hooks","index":"10"},{"id":"第-11-章-课程总结","title":"第 11 章 课程总结","index":"11"}],"reading_time":"1083 字约 7 分钟"}