{"title":"前端架构思考随笔","date":"2020-01-07T13:35:13.000Z","date_formatted":{"ll":"2020年1月7日","L":"2020/01/07","MM-DD":"01-07"},"link":"20200107/前端架构思考随笔","tags":["前端架构"],"updated":"2020-01-13T12:56:05.000Z","content":"<h1 id=\"前端架构\">前端架构<a title=\"#前端架构\" href=\"#前端架构\"></a></h1>\n<p>强业务相关，视图业务尽量解耦（可以实现跨端）</p>\n<h3 id=\"--common-公共\">- Common 公共<a title=\"#--common-公共\" href=\"#--common-公共\"></a></h3>\n<ul>\n<li>utils 工具函数</li>\n<li>constans 变量</li>\n<li>types 类型</li>\n</ul>\n<h3 id=\"--infrastructure-层-对底层技术进行封装操作（aop）\">- infrastructure 层 对底层技术进行封装操作（AOP）<a title=\"#--infrastructure-层-对底层技术进行封装操作（aop）\" href=\"#--infrastructure-层-对底层技术进行封装操作（aop）\"></a></h3>\n<blockquote>\n<p>如果有跨平台要求，最好是在这一层抹平平台之间的差异（平台相关的），基础设施层级</p>\n<ul>\n<li>\n<p>以前写thinkphp，对不同平台代码进行适配的情况会有一个driver的想法，</p>\n</li>\n<li>\n<p>ethers.js 中 对 Provider 的封装就是也是这个思路</p>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>封装 AJAX 请求\n<ul>\n<li>AJAX中有 translator 转换器层，主要是对后端提供的接口进行数据的转换修正，</li>\n</ul>\n</li>\n<li>操作浏览器 cookie、locaStorage、indexDB，</li>\n<li>操作 native 提供的能力（如调用摄像头等），</li>\n<li>建立 Websocket 与后端进行交互等。</li>\n</ul>\n<h3 id=\"--领域-domain-层\">- 领域 Domain 层<a title=\"#--领域-domain-层\" href=\"#--领域-domain-层\"></a></h3>\n<blockquote>\n<p>实体由数据表达，实体中的函数都是由数据中加逻辑而成的，不依赖外部，形成单独的领域概念</p>\n</blockquote>\n<h4 id=\"实体-entity\">实体 Entity<a title=\"#实体-entity\" href=\"#实体-entity\"></a></h4>\n<h3 id=\"--service-服务层\">- Service 服务层<a title=\"#--service-服务层\" href=\"#--service-服务层\"></a></h3>\n<blockquote>\n<p>依赖 infrastructure 和 Domain 层，可使用不同的领域，用 infrastructure  的功能实现不同的 Service</p>\n<p>面向数据（Entity），不是面向业务</p>\n</blockquote>\n<h4 id=\"数据访问层-dao-service（这是最主要的）\">数据访问层 DAO Service（这是最主要的）<a title=\"#数据访问层-dao-service（这是最主要的）\" href=\"#数据访问层-dao-service（这是最主要的）\"></a></h4>\n<blockquote>\n<p>依赖于 Entity 和  Infrastructure （平台无关）</p>\n</blockquote>\n<ul>\n<li>后端：sql-&gt;param-&gt;getResult</li>\n<li>前端：url-&gt;param-&gt;getResult</li>\n<li>所谓事务，是指</li>\n<li>后端实现，按不同的需求调用不同的数据访问层方法，这里有事务的概念。</li>\n<li>前端实现，按不同的需求调用不同的数据访问层方法，这里不需要事务的概念，一定要有的话，一个是后端可以帮你变没有，一个是用 Promise.all 吧。事务这个概念在前端基本不存在，或者这种情况不多，但总有变通的办法嘛~</li>\n</ul>\n<h4 id=\"other-service-其他-service\">Other Service 其他 Service<a title=\"#other-service-其他-service\" href=\"#other-service-其他-service\"></a></h4>\n<ul>\n<li>本地储存 / 文件持久化</li>\n<li>websocket 连接</li>\n<li>图像处理…</li>\n</ul>\n<h3 id=\"--application-用户逻辑层-，\">- application 用户逻辑层 ，<a title=\"#--application-用户逻辑层-，\" href=\"#--application-用户逻辑层-，\"></a></h3>\n<blockquote>\n<p>依赖 Service 层，可使用不同的 Service</p>\n<p>面向业务，以业务为中心进行Service的调度。</p>\n</blockquote>\n<h3 id=\"state-bridge-状态桥\">State Bridge 状态桥<a title=\"#state-bridge-状态桥\" href=\"#state-bridge-状态桥\"></a></h3>\n<blockquote>\n<p>ViewModel 中的 M，</p>\n</blockquote>\n<h3 id=\"input-interface-用户输入层\">input Interface 用户输入层<a title=\"#input-interface-用户输入层\" href=\"#input-interface-用户输入层\"></a></h3>\n<ul>\n<li>\n<p>后端实现， 拿到前端传回的参数，格式化数据，调用业务逻辑层的方法。格式化结果，返回数据。</p>\n</li>\n<li>\n<p>前端实现，拿到用户数据，格式化数据，调用业务逻辑层的方法，格式化结果，渲染页面。（基本都是View层）</p>\n</li>\n</ul>\n<h2 id=\"分层介绍\">分层介绍<a title=\"#分层介绍\" href=\"#分层介绍\"></a></h2>\n<h3 id=\"domain层\">domain层<a title=\"#domain层\" href=\"#domain层\"></a></h3>\n<p>在这一层中，我们可以定义充当实体和业务规则的角色并与我们的域有直接关系的单元。例如，在用户和团队的应用程序中，我们可能会有一个<code>User</code>实体，一个<code>Team</code>实体和一个<code>JoinTeamPolicy</code>来回答用户是否能够加入给定的团队。</p>\n<p>这是我们软件中最隔离，最重要的层，应用程序层可以使用它来定义<em>用例</em>。</p>\n<h3 id=\"application层\">application层<a title=\"#application层\" href=\"#application层\"></a></h3>\n<p>应用程序层定义了我们应用程序的实际行为，因此负责执行域层各单元之间的交互。例如，我们可以有一个<code>JoinTeam</code> <em>用例</em>，用于接收<code>User</code>和的实例<code>Team</code>并将其传递给<code>JoinTeamPolicy</code>;。如果用户可以加入，它将持久性责任委托给基础结构层。</p>\n<p>应用程序层也可以用作基础结构层的<u><em><strong>适配器</strong></em></u>。假设我们的应用程序可以发送电子邮件；负责直接与电子邮件服务器交谈的类（我们称之为<code>MailChimpService</code>）属于<em>基础结构层</em>，但实际发送电子邮件的类（<code>EmailService</code>）属于<em>应用程序层</em>并在<code>MailChimpService</code>内部使用。因此，我们的应用程序的其余部分不知道有关特定实现的详细信息-它仅知道<code>EmailService</code>能够发送电子邮件。</p>\n<h3 id=\"infrastructure-层\">infrastructure 层<a title=\"#infrastructure-层\" href=\"#infrastructure-层\"></a></h3>\n<p>这是所有层中的最低层，它是应用程序外部的边界：数据库，电子邮件服务，队列引擎等。</p>\n<p><em>多层</em>应用程序的一个共同特征是使用<a href=\"https://martinfowler.com/eaaCatalog/repository.html\" target=\"_blank\"><em>存储库模式</em></a>与数据库或其他一些外部持久性服务（例如API）进行通信。存储库对象本质上被视为集合，使用它们的层（<em>域</em>和<em>应用程序</em>）不需要知道底层的持久性技术（类似于我们的电子邮件服务示例）。</p>\n<p>这里的想法是存储库<a href=\"https://en.wikipedia.org/wiki/Interface_(computing)#Software_interfaces_in_object-oriented_languages\" target=\"_blank\">接口</a>属于 domain 层，而实现又属于 infrastructure  层，</p>\n<p><em>即</em>域仅知道存储库接受的方法和参数。即使在测试方面，这也使两层都更加灵活！由于JavaScript并未实现接口的概念，因此我们可以想象自己的接口，并以此为基础在基础结构层上创建具体的实现。</p>\n<h3 id=\"input-interface-层\">input interface 层<a title=\"#input-interface-层\" href=\"#input-interface-层\"></a></h3>\n<p>该层包含应用程序的所有入口点，例如控制器，CLI，websocket，图形用户界面（如果是桌面应用程序）等等。</p>\n<p>它应该不具有有关业务规则，用例，持久性技术的知识，甚至不具备其他逻辑的知识！它应该只接收用户输入（如URL参数），将其传递给<em>用例</em>，最后将响应返回给用户。</p>\n<h3 id=\"前后端对比\">前后端对比<a title=\"#前后端对比\" href=\"#前后端对比\"></a></h3>\n<p>其中 domain 层和 application 层在前端和后端之间是没有什么不同的，因为它们是与技术无关的，但是对于 input 层和 infrastructure 层我们不能这么说。</p>\n<p>在 Web 浏览器中 input 层通常只有一个角色–view。</p>\n<p>所以我们甚至可以称之为 view 层。</p>\n<p>同样在前端是无法操作数据库或队列引擎的，所以我们无法在前端的 infrastructure 层中找到它们。</p>\n<p>相反我们能够找的是封装 AJAX 请求、浏览器 cookie、LocalStorage，甚至是与 WebSocket 服务器交互的模块的抽象。</p>\n<h4 id=\"所以对应来说\">所以对应来说<a title=\"#所以对应来说\" href=\"#所以对应来说\"></a></h4>\n<p>domain 领域层 ，application 应用层 前后端应可以完全复用模块</p>\n<p>input层，对于后端来说主要是Controller 接受 url 参数，对于前端来说就是View层。</p>\n<p>infrastructure ，就是不同平台上对底层技术进行封装操作的一层，尽量抹平平台之间的差异。</p>\n<p>主要的区别是被抽象的内容，所以前端和后端的 <a href=\"https://martinfowler.com/eaaCatalog/repository.html\" target=\"_blank\">Repository</a> 甚至可以有完全一致的接口而底层是不同的技术。你能看到一个好的抽象有多棒了吗？</p>\n<p><img src=\"https://camo.githubusercontent.com/e086c208c3af9fa2439ef95b26c1b97efe79cac8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f392f32342f313664363131303962366532666332333f773d3133383826683d33363826663d706e6726733d3330303635\" alt=\"img\"><br>\n<a href=\"https://camo.githubusercontent.com/e086c208c3af9fa2439ef95b26c1b97efe79cac8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f392f32342f313664363131303962366532666332333f773d3133383826683d33363826663d706e6726733d3330303635\" target=\"_blank\"></a></p>\n<p>关于基于前端分层的架构，还有另一个重要规则：使 view 层始终与本地状态保持同步，你应该遵循单向数据流原则。我们可以通过添加第五个层来达到这个目的：state ，或者称为 store。</p>\n","prev":{"title":"使用husky和lint-staged来构建你的前端工作流","link":"20200107/使用husky和lint-staged来构建你的前端工作流"},"next":{"title":"feflow WeFlow 工程化实践","link":"20200106/feflow工程化实践"},"plink":"http://reamd7.github.io/20200107/前端架构思考随笔/","toc":[{"id":"前端架构","title":"前端架构","index":"1","children":[{"id":"--common-公共","title":"- Common 公共","index":"1.1"},{"id":"--infrastructure-层-对底层技术进行封装操作（aop）","title":"- infrastructure 层 对底层技术进行封装操作（AOP）","index":"1.2"},{"id":"--领域-domain-层","title":"- 领域 Domain 层","index":"1.3"},{"id":"--service-服务层","title":"- Service 服务层","index":"1.4"},{"id":"--application-用户逻辑层-，","title":"- application 用户逻辑层 ，","index":"1.5"},{"id":"state-bridge-状态桥","title":"State Bridge 状态桥","index":"1.6"},{"id":"input-interface-用户输入层","title":"input Interface 用户输入层","index":"1.7"}]},{"id":"分层介绍","title":"分层介绍","index":"2","children":[{"id":"domain层","title":"domain层","index":"2.1"},{"id":"application层","title":"application层","index":"2.2"},{"id":"infrastructure-层","title":"infrastructure 层","index":"2.3"},{"id":"input-interface-层","title":"input interface 层","index":"2.4"},{"id":"前后端对比","title":"前后端对比","index":"2.5"}]}],"reading_time":"1646 字约 11 分钟"}